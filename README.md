# Python Profiler: Полное руководство по профилированию кода от Python до системных вызовов


# СТАТЬЯ ЕЩЕ НЕ ЗАКОНЧЕНА

Данный репозиторий содержит исходный код статьи (LaTeX) и готовый PDF-файл, посвящённый всестороннему анализу производительности Python-приложений. Если ваш код работает медленно, а вы не знаете, где искать «узкие места» — эта статья для вас.

## О чём эта статья?

Профилирование — ключевой этап оптимизации. Но Python — сложная экосистема: ваш код исполняется не только в интерпретаторе, но и в нативных расширениях (C extensions), а также взаимодействует с операционной системой. Чтобы действительно понять, куда уходит время, нужно уметь пользоваться инструментами на **всех уровнях**.

В этой статье мы:
- Разбираем **теоретические основы** профилирования (инструментирование vs сэмплирование).
- Изучаем **встроенные и сторонние профилировщики** Python: от устаревшего `profile` до современного `cProfile`, построчного `line_profiler`, многопоточного `yappi` и семплирующего `py-spy`.
- Заглядываем **вглубь нативных расширений** и показываем, как профилировать C/C++ код, вызываемый из Python (gprof, Valgrind, Google PerfTools).
- Опускаемся **до уровня ядра** и учимся использовать `perf`, `DTrace` и `eBPF` для анализа системных вызовов, I/O и смешанных стеков (Python + C).
- Завершаем **сравнением и практическими рекомендациями**, которые помогут выбрать правильный инструмент под вашу задачу.

## Почему стоит прочитать?

- Вы **начинающий** и хотите понять, как искать причины тормозов в Python-коде.
- Вы **опытный разработчик** и сталкивались с ситуациями, когда стандартный `cProfile` не даёт ответов (например, тормозят C-расширения или многопоточность).
- Вы **администратор** или **DevOps** и хотите профилировать приложения в продакшене без остановки сервиса.
- Вы просто любите **глубоко разбираться** в работе программ.

## Содержание статьи (кратко)

1. **Введение** — мотивация, объект, предмет и цели исследования.
2. **Теоретические основы** — виды профилирования, их плюсы и минусы, уровни анализа.
3. **Профилирование на уровне Python** — `profile`, `cProfile`, `line_profiler`, `memory_profiler`, `yappi`, `py-spy`, `pprofile`.
4. **Профилирование C extensions** — gprof, Valgrind, Google PerfTools, смешанные стеки.
5. **Системное профилирование** — perf, DTrace, eBPF, анализ I/O.
6. **Сравнение и рекомендации** — таблица характеристик, выбор под задачу.
7. **Заключение** — выводы и дальнейшие шаги.

## Как получить PDF?

Вы можете:
- Скачать готовый [`notes.pdf`](./notes.pdf) прямо из репозитория.
- Собрать PDF самостоятельно, если у вас установлен LaTeX:
  ```bash
  pdflatex main.tex
  ```
  (или используйте `latexmk`).

## Инструменты, рассмотренные в статье

| Категория                  | Инструменты                                                                 |
|----------------------------|-----------------------------------------------------------------------------|
| Встроенные профилировщики  | `profile`, `cProfile`, `pstats`                                             |
| Построчный анализ          | `line_profiler`                                                             |
| Профилирование памяти      | `memory_profiler`                                                           |
| Многопоточность / asyncio  | `yappi`                                                                     |
| Семплирование (продакшен)  | `py-spy`, `pprofile` (стат. режим)                                          |
| Нативный код (C/C++)       | `gprof`, `Valgrind (callgrind)`, `Google PerfTools`                         |
| Системный уровень          | `perf`, `DTrace`, `eBPF`, `strace`, `ioprof`                                |

## Лицензия

Материал распространяется под лицензией MIT (если не указано иное). Вы можете свободно использовать, копировать и модифицировать текст с указанием авторства.

## Обратная связь

Автор: **Oleg Shipulin**  
Если у вас есть вопросы, замечания или предложения по улучшению — создавайте Issue или Pull Request. Буду рад обратной связи!

---

**Приятного чтения и быстрого кода!**
